## 毕业项目

### JVM

JVM是指java虚拟机，java和其他语言不一样，内存的回收管理不是开发者自己做的(比如C)，是交给java虚拟机做的，这样极大的减轻了开发者的负担。

java能跨平台主要是因为字节码的原因，因为先将不同平台的java文件编译成统一的字节码文件，然后再由虚拟机解析即可。

jvm内存结构：

jvm是基于栈的内存模型，每个线程都有自己独立的线程栈，线程栈内的属性其他线程是看不见的。

每个方法会在线程栈里面创建一个栈帧，用来存储方法内的参数和返回值。

堆是所有线程共享的一块空间，jvm将堆分为年轻代和老年代，年轻代分为三个区域，新生代和存活区，存活区又分为s0和s1.gc算法主要就是回收这里的空间。

非堆不归gc管，里面有个元数据区，在以前叫持久代。

jvm有很多启动参数，可以控制虚拟机的启动形式。

##### GC算法：

- 串行GC (Serial GC) 单线程清除算法
- 并行GC (Parallel GC) 多线程清除算法 还是会造成stw
- CMS GC  在并行GC上做了优化，对老年代清除不再是占用所有cpu了，而是和应用线程一起执行。
- G1 GC   将内存划分为多个region，不再收集整个内存空间，而是按增量方式处理，每次只处理一部分内存块，每次GC暂停都会收集所有年轻代的内存块， 但一般只包含部分老年代的内存块
- ZGC GC最大停顿时间不超过10ms，支持内存范围广
- ShennandoahGC  GC暂停时间和堆大小无关

### NIO

NIO即非阻塞IO(non-block io)，主要用于网络通信，由于没有阻塞所以在高并发场景下运用的很多，主要实现框架为Netty。

Netty是一个异步、事件驱动，基于NIO的高并发框架，拥有高吞吐，低延迟，低开销的特性。

Netty框架的几个关键对象：

- Bootstrap: 启动线程，开启 socket（可以是服务端可以是客户端）
- EventLoopGroup  循环事件组
- EventLoop   循环事件
- SocketChannel: 连接
- ChannelInitializer: 初始化
- ChannelPipeline: 处理器链
- ChannelHandler: 处理器

Netty数据网络传输因为发送的数据库大小不一致，如果不预定传输格式，接收方可能得不到正确的信息。这就是所谓的**粘报拆包**问题，这就需要对数据进行相应的编码和解码。

Netty应用：API网关

API网关作用主要是拦住所有服务请求，对齐进行安全、验证、路由、过滤、流控等策略之后发送到后端业务服务，可以对所有API进行统一管理。

### 并发编程

并发编程一直是JAVA里面的一个大头，作为现在多核处理器爆发的年代，并发编程的适用范围十分的广。

JAVA并发编程主要集中在多线程的知识，需要了解基础，比如守护线程，线程创建集中形式，线程有哪些状态等，线程的常见操作方式等。

为了节省线程创建的消耗，引入线程池，做到线程高效利用。

线程会有并发安全问题，当多个线程同时操作一个资源，如果对资源访问顺序敏感，会造成竞态条件。JAVA里面对这种处理就是引入锁的概念，既然多个会存在竞态条件，那就一个个去，并发主要有三个性质：

- 原子性
- 可见性
- 顺序性

只要确保这三点，那就能安全操作线程。

锁可以用synchronized关键字和Lock，volatile可以保证有序性和可见性，但不能保证原子性。

线程池常见创建方式，参数等都需要掌握，线程池容量，缓冲队列设置，遗弃策略。

Java并发包对多线程处理进行了全面升级，操作变得更为简单。

因为synchronized 方式存在以下问题，所以引入显示的锁Lock

- 同步块的阻塞无法中断（不能 Interruptibly）
- 同步块的阻塞无法控制超时（无法自动解锁）
- 同步块无法异步处理锁（即不能立即知道是否可以拿到锁）
- 同步块无法根据条件灵活的加锁解锁（即只能跟同步块范围一致）

Lock相关API的掌握，已经对应的`Condition`,`LockSupport`使用。

无锁的 Atomic 工具类，CAS指令，自旋等概念。

AQS抽象队列同步器概念，Semaphore，CountdownLatch，CyclicBarrier等工具类使用。

### Spring 和 ORM 等框架

前面差不多将JAVA基础知识里面几个关键点都过完了，在实际开发时，我们都不是从头开始写，一来很慢，二来很多新手其实没那个实力，因为很多底层东西不知道，自己写的话又耗时又费力，一般是直接在框架的基础上进行编写，正所谓框架在手天下我有。

Spring是JAVA开发领域一个大名鼎鼎的框架，作为JAVA开发基本没有不知道的。

它主要有两大特性：

- IOC容器
- AOP

Spring的**IOC容器**做到了对类依赖的充分解耦，开发人员再也不需要对嵌套很深的类进行很长的初始化了，而直接通过配置的方式，将其讲给IOC容器去实现。

Spring里面将所有初始的类都称为Bean，只要将这个Bean配置到IOC容器之后，它在启动容器的时候都会去初始化这个Bean，如果初始化失败会抛出异常，一旦程序启动成功，那你一定是能拿到这些Bean的，这样开发就可以将更多的心思放到业务代码的开发了。

Spring还提供了很多接口给我们操作bean，比如初始化的时候，还有bean的前置和后置操作接口等。

AOP是一个切面的概念，运用动态代理技术，生成一个代理对象将该方法拦截下来，然后在代理对象里可以设置前置方法，后置方法和环绕方法，以及异常方法，从而实现对拦截方法的增强。当这些处理之后才会调用实际的方法。AOP的优势是不需要改动原有代码，直接动态的在代码执行时生成代理对象，这样实现了对代码的最小侵入，十分的灵活。

Spring boot两大特性，自动化配置和Spring-boot-start(脚手架)

ORM框架即对象关系映射框架，它是在JDBC上进行了轻量级封装，其实所有和数据库的操作都是基于JDBC的，常用的ORM框架主要有两种，Hibernate和MyBatis。实际上MyBatis使用的多点，因为对DBA比较友好，能很好的看见查询的语句，能更好的优化，提出建议。

其他框架如Lambda，Java 8 的Stream，Lombok等基本都用过，不过多赘述。

### MySQL 数据库和 SQL

我们现在线上项目出现性能问题一般都发生在数据库端，其实服务器端（代码端）发生的可能性其实是很小的。那实际上我们要优化的其实也就是数据库，特别是并发量达到一定程度之后，单一的数据库一定是承受不住的，这时候就需要主从分离，分库分表，或者引入缓存等，**做这么多其实就是一个目的，将单一数据库的压力降到它能承受的程度。**

数据库其实也分很多种，关系型数据库如Mysql，Postgresql，sqlserver等，缓存数据库 Redis等。Mysql是现在使用最多的数据库，主要是因为它开源免费的，SQL语言是一个操作数据库的语言，我们可以用SQL语言对数据库进行任何操作，只要你权限足够。

Mysql引擎有myisam,innodb,memory,archive等，我们常用的是innodb，mysql的索引一般是用B+树实现，事务模型主要是原子性、一致性、隔离性、持久性。mysql分为表级锁和行级锁，mysql的事务隔离级别有以下四种：

- 读未提交 : READ UNCOMMITTED
- 读已提交 : READ COMMITTED
- 可重复读 : REPEATABLE READ
- 可串行化

理清mysql的undo log和redo log概念。

索引的建立，用哪个字段，一般采用最左原则，一般重复越少的字段作为索引越好，一个小tips，如果一个数据量较大的表有索引，在插入的时候也会需要更新索引，会变得很慢，可以先将索引去掉在插入数据，等插入完成之后再重建索引。

### 分库分表

首先，我们看下为啥要分库分表，一个主要原因是单一数据库容量有限难以扩容，成本较高，而且QPS过大会影响性能，如果数据库出问题业务就完全没法用了。

然后我们引入了**主从复制模式**，但是还是不能解决高可用问题，因为访问量还是那么大，于是引入了**读写分离**，将数据库功能分离，主库只负责写，然后将数据同步给从库，用户从从库读取数据，大大减轻了主库压力。因为其实实际线上读的操作是远大于写的操作的，所以多分几台读的库，能很好降低压力。灾备方面，因为有主从复制，所以即使某个库死掉了，也可以暂时从其他库读取数据，或者直接拿其他库顶上。实现有 MHA和 MGR、 MySQL Cluster、 Orchestrator等。

当一个库的表过大，我们需要将其进行拆分，拆分可以分为水平拆分和垂直拆分，进行分布式，多个数据库作为数据库分片集群对外提供服务。我们其实数据库和表都能这样拆。

垂直拆分就是将功能不同的库分别拆成单一的库，或者业务含义不一致的表字段分别拆成几张不同的子表。

水平拆分是指某个一个库数据量实在太大，放在一起访问速度很慢，于是按照一定分片规则拆成多个库和表，比如一个库的数据量是1亿，然后我们拆成1024个库，平分这些数据量，每个库数据量就是1亿/1024，量一下就降下来了。水平拆分主要有两种依据，一个是按主键拆分，一个是按时间拆分。业务侧一般搭配对应的分库分表框架来使用，如ShardingSphere。

### RPC 和微服务

RPC即远程过程调用，简单来说就是像调用本地方法一样调用远程方法。

其核心原理就是利用代理机制，在本地存根，然后序列化或者反序列化发到服务端，服务端序列化或反序列化，远程服务存根，调用远程结果，返回结果。

常见RPC技术有JAVA RMI,Hessian，gRPC等。

微服务架构其实是分布式业务架构，它有以下一些特性：

- 运用分布式与集群对多个相同服务进行管理
- 引入注册中心实现服务注册发现机制
- 实现集群路由和负载均衡
- 过滤、流控实现熔断限流等治理功能

微服务一般试用于业务复杂度较高的场景，可以很好的保持生产力。

微服务发展的几个阶段：

1.  响应式微服务
2.  服务网格与云原生
3. 数据库网格
4. 单元化架构

### 分布式缓存

缓存是提升系统性能的一个简单有效的办法，缓存在我看来就是将一些常用或者已经使用过的数据存储起来，如果下次来查询，直接将这些数据返回而不需要再次查询数据库。缓存有效性的两个指标为**读写比**和**命中率**。

缓存分为本地缓存和远程缓存，如果是分布式服务，一般都使用的缓存中间件，比如Redis，或者内存网格Hazelcast。

掌握缓存穿透，缓存击穿，缓存雪崩等术语。

我们缓存里面使用的比较多的是Redis.它主要有string,hash,list,set,sorted set五种数据结构。前四种和java里的数据类型类似，第五种除了是set之外，还会对应一个分数，能对里面元素进行排序。

Redis内存处理模式是单线程，但是io线程6之前是单线程，6之后引入NIO之后变成多线程了。

Redis可以用作业务数据缓存，也可以对数据计数，也可以处理数据，比如去重，也可以全局计数，发布订阅(简单的mq功能)，以及实现分布式锁。

Redis三个客户端框架分别为Jedis，Lettuce和Redission，不太推荐Jedis，太老效率低，推荐使用Lettuce和Redission，其中Redission提供了大量分布式功能，操作十分方便。

掌握Redis的主从复制，哨兵，主从切换，以及Redis Cluster的配置。

### 分布式消息

由于我们采用了微服务架构将系统拆成了多个业务分离子系统，他们之间常常需要进行消息通信，那使用什么消息通信方式是最好的呢？

常用的有

1. 文件，
2. Socket（网络），
3. 数据库，
4. RPC，

13都不是实时的，需要接收方主动去获取消息，24虽然及时，但是2不如4,4访问大了之后处理不过来，没有很好的缓冲手段。

于是MQ（消息队列）出来了。

我们知道内存里的queue其实是有顺序和缓冲的功能的，消息队列也继承了这些优点。所有系统的消息再发给消息队列之后，消息队列会发给相应的系统，从而达到消息通信的目的，且两个系统之间是完全解耦的，异步的，当其中一个不可用并不会影响到另外一个，如果是传统的模式那这次消息传输就失败了，需要重传。

MQ四大优点

- 异步通信：异步通信，减少线程等待，特别是处理批量等大事务、耗时操作。
- 系统解耦：系统不直接调用，降低依赖，特别是不在线也能保持通信最终完成。
- 削峰平谷：压力大的时候，缓冲部分请求消息，类似于背压处理。
- 可靠通信：提供多种消息模式、服务质量、顺序保障等。

消息队列有两种消息处理模式：

1. 点对点：一对一
2. 发布订阅：一对多

常见的消息队列框架有ActiveMQ,RabbitMQ,Kafka,RocketMQ,Apache Pulsar等。如果对吞吐量有要求建议用Kafka,如果需要嵌入到应用系统可以使用ActiveMQ。