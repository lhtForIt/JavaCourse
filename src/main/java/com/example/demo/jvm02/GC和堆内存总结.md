### GC和堆内存总结

串行GC：总体来说效率还是很低的，因为是单线程，young gc和old gc不能同时进行，比如在触发full gc的时候只能进行old gc，young gc只能等待。唯一优点是cpu利用率高，除非很老的机子，不然不建议使用。

并行GC: 相对于串行gc升级了多线程功能，利用cpu的多核性质，极大的提高了gc效率。它可以同时进行young gc和full gc，因此大大压缩了gc暂停时间。

CMS GC: CMS相对于串行GC又有了升级，年轻代采用的标记复制算法，对老年代使用的并发标记清除算法，而且CMS的标记清除大部分工作是和应用线程一起工作的，所以代表这个动作是一直在执行的，这样把大部分没必要的stw时间抽取了出来，极大的降低了整体的gc停顿。**但是它也有缺点，就是老年代内存不压缩，在特殊情况下引发不可预测的暂停。**

G1 GC: G1 GC在前面几代的基础上，对堆不再是分为年轻代和老年代 ，而是划分为多个小块，一般是2048个，每个小块即可能是新生区，也可能是存活区，也可能是老年区。这样它每次收集的时候只是以增量的方式处理一部分内存块，这个内存块被称为回收集。因为是以块为单位收集，很大程度上降低了收集时间。**某些情况下GC触发Full GC,将会退化为串行GC，导致GC暂停时间变大很多。**

ZGC:本地jdk版本太低，运行不了。暂不讨论。

ShenandoahGC:本地jdk版本太低，运行不了。暂不讨论。



就我目前演练查看的结果看来，所有GC算法和配置的堆内存都是一样的，随着堆内存增大，gc次数减少，但是gc消耗时间变大，基本是呈倍数关系。其实我理解就是一种空间换时间的思维，当你想要gc发生的次数变少，这时候可以通过增大最大内存来达到目的，但是相应的，一旦触发full gc时，这时候需要清理的内存会比以前堆内存小的时候花费的时间更多，因为你要清理的内存变得更大了。所以实际项目中我们应该根据具体的场景去考虑，这里面不存在绝对的最优，只有相对于该场景的最优GC算法。